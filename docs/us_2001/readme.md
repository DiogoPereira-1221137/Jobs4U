# US 2001


## 1. Context

This task is being assigned for the first time. 
The task itself consists of developing code in the C programming language using Process management, Signals and Pipes to continuously process files in order for them to be imported by the Operator at a later time.

## 2. Requirements


**US 2001**  As Product Owner, I want the system to, continuously, process the files produced by the Applications Email Bot, so that they can be imported into the system by initiative of the Operator..

**Acceptance Criteria:**

- The system continuously processes the files located in the Email Bot output folder until there are no files left, at which point it will be left on standby until a new file is added.


**Customer Specifications and Clarifications:**
> **Question:** Bot restarts, duplicate files and final report. I would like to know what is the expected behaviour when the Application File Bot is restarted. Since the requirements state that files should be copied and not moved, the bot must know which files may have been already copied during previous runs of the program. Should the bot, on startup, check if the existing files were already copied to the shared folder, should the files be moved instead of copied or any other solution? If you have no specific requirements for this case, only that the system is kept in a consistent state, I'd like to know what is the expected behaviour when the bot finds duplicate files. I'd also like to know if the file prefix generated by the Application Email Bot is guaranteed to be numeric and unique throughout the whole software solution lifecycle. One more question, regarding how the report system works. Should the bot create a report each time new files are found and moved to the shared folder, meaning that there are multiple reports simultaneously (for instance, identified via date and time in the file name), or should it be a single file to which new data is appended?
>
> **Answer:** A lot of questions for “a single question”. As stated in your question, the system should be kept in a consistent state. Regarding duplicate files, there should not be any duplicate files (why would duplicate files exist?). Regarding the report, there can be multiple report files, each one uniquely identified by some sort of timestamp.

> **Question:** Number of Files. Regarding EmailFileBot, it previously responded that "All other files with the same prefix must be considered attachments", is there a maximum/valid number of files allowed as attachments? Or do we not control the number of files submitted per application? Example: CV, Email, Candidate-data and optional x?
>
> **Answer:** A maximum number is not defined, but you can establish a limit to be configured, for example, in a configuration file containing a limit on size (Mb) or number of attachments.

> **Question:** What type of information will the report made by the Application File Bot contain? Since this report will be about multiple applications, how often should it be created?
>
> **Answer:** See *[first question on this list]*. I am not a technical person, but I should say that the report should include information that is enough for diagnosing problems in the import. I think some form of configuration of detail to be reported should be interesting, like what is usually available for log files, with a default rule for maximum detail.

> **Question:** Running Configurations – We would like clarification regarding the parameter selection method for running the application. In the help document for this functionality, we are informed that this configuration can be done through a configuration file or through direct input when running the application via the command line. Our question is: can we choose a priori the way the configuration is done (configuration file or input), or does the group decide which method will be used for the application under development?
>
> **Answer:** I think that the document you refer to is not the main system specification document, it will be a complementary document with a specific specification of a curricular unit. Therefore, I think they should clarify the issue elsewhere. But, without wanting to condition the “official” answer (which is not this one), I think it is an option, and that each solution can consider which one follows.

> **Question:** New and old files – Regarding the us2001 functionality, the files generated by the Application Email Bot are placed in a directory and then processed by the File Bot. After a file is processed by File Bot, can it be deleted from the directory used by Email Bot to store the files, since they are already organized in a shared folder?
>
> **Answer:** See *[first question on this list]*. As a product owner I have no specific requirements regarding this aspect. I just hope that the System always maintains the integrity of the data and that it is not “lost”.

[//]: # (> **Question:**)

[//]: # (>)

[//]: # (> **Answer:**)

**Dependencies/References:**

The “Applications File Bot” must be developed in C and utilize processes, signals,
pipes, and exec function primitives.

A child process should be created to periodically monitor an input directory for new
files related to the 'Application' phase of the recruitment process. If new files are
detected, a signal should be sent to the parent process.

Please refer to Section 2.2.3 of the “System Specification” document for a
description of the input directory, input files, output directory, and their expected
subdirectories.

Upon receiving a signal, the parent process should distribute the new files among a
fixed number of worker child processes. Each child process will be responsible for
copying all files related to a specific candidate to its designated subdirectory in the
output directory.

Once a child has finished copying all files for a candidate, it should inform its parent
that it is ready to perform additional work. Child workers do not terminate unless they
are specifically terminated by the parent process.

Once all files for all candidates have been copied, the parent process should
generate a report file in the output directory. This report should list, for each
candidate, the name of the output subdirectory and the names of all files that were
copied.

To terminate the application, the parent process must handle the SIGINT signal.
Upon reception, it should terminate all children and wait for their termination.
The names of the input and output directories, the number of worker children, the
time interval for periodic checking of new files, etc., should be configurable. This
configuration can be achieved either through input parameters provided when
running the application or by reading from a configuration file.
Unit and integration tests are highly valued.


## 3. Analysis

[//]: # (*In this section, the team should report the study/analysis/comparison that was done in order to take the best design decisions for the requirement. This section should also include supporting diagrams/artifacts &#40;such as domain model; use case diagrams, etc.&#41;,*)
#### Information from Client Questions
- There can be multiple report files, each one uniquely identified by some sort of timestamp.
- A limit may be configured through a configuration file.




[//]: # (## 4. Design)
[//]: # ()
[//]: # (*In this section, the team should present the solution design that was adopted to solve the requirement. This should include, at least, a diagram of the realization of the functionality &#40;e.g., sequence diagram&#41;, a class diagram &#40;presenting the classes that support the functionality&#41;, the identification and rational behind the applied design patterns and the specification of the main tests used to validate the functionality.*)
[//]: # ()
[//]: # (### 4.1. Realization)
[//]: # ()
[//]: # (### 4.2. Class Diagram)
[//]: # ()
[//]: # (![a class diagram]&#40;class-diagram-01.svg "A Class Diagram"&#41;)
[//]: # ()
[//]: # (### 4.3. Applied Patterns)
[//]: # ()
[//]: # (### 4.4. Tests)
[//]: # ()
[//]: # (Include here the main tests used to validate the functionality. Focus on how they relate to the acceptance criteria.)
[//]: # ()
[//]: # (**Test 1:** *Verifies that it is not possible to ...*)
[//]: # ()
[//]: # (**Refers to Acceptance Criteria:** G002.1)
[//]: # ()
[//]: # ()
[//]: # (```)
[//]: # (@Test&#40;expected = IllegalArgumentException.class&#41;)
[//]: # (public void ensureXxxxYyyy&#40;&#41; {)
[//]: # (	...)
[//]: # (})
[//]: # (````)
[//]: # ()
[//]: # (## 5. Implementation)
[//]: # ()
[//]: # (*In this section the team should present, if necessary, some evidences that the implementation is according to the design. It should also describe and explain other important artifacts necessary to fully understand the implementation like, for instance, configuration files.*)
[//]: # ()
[//]: # (*It is also a best practice to include a listing &#40;with a brief summary&#41; of the major commits regarding this requirement.*)
[//]: # ()
[//]: # (## 6. Integration/Demonstration)
[//]: # ()
[//]: # (*In this section the team should describe the efforts realized in order to integrate this functionality with the other parts/components of the system*)
[//]: # ()
[//]: # (*It is also important to explain any scripts or instructions required to execute and demonstrate this functionality*)
[//]: # ()
[//]: # (## 7. Observations)
[//]: # ()
[//]: # (*This section should be used to include any content that does not fit any of the previous sections.*)
[//]: # ()
[//]: # (*The team should present here, for instance, a critical perspective on the developed work including the analysis of alternative solutions or related works*)
[//]: # ()
[//]: # (*The team should include in this section statements/references regarding third party works that were used in the development this work.*)